<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tutorial 2.4: Noções sobre IO-Scheduler e acesso a disco (v1.0)</title>
<meta name="generator" content="http://txt2tags.org">
<link rel="stylesheet" href="tutorial.css">
<style>
body{background-color:#fff;color:#000;}
hr{background-color:#000;border:0;color:#000;}
hr.heavy{height:5px;}
hr.light{height:1px;}
img{border:0;display:block;}
img.right{margin:0 0 0 auto;}
img.center{border:0;margin:0 auto;}
table th,table td{padding:4px;}
.center,header{text-align:center;}
table.center {margin-left:auto; margin-right:auto;}
.right{text-align:right;}
.left{text-align:left;}
.tableborder,.tableborder td,.tableborder th{border:1px solid #000;}
.underline{text-decoration:underline;}
</style>
</head>
<body>
<header>
<hgroup>
<h1>Tutorial 2.4: Noções sobre IO-Scheduler e acesso a disco (v1.0)</h1>
</hgroup>
</header>
<article>

<nav>
<div class="body" id="body">

  <ol>
  <li><a href="#toc1">Objetivo</a>
  </li>
  <li><a href="#toc2">Criando uma imagem de disco</a>
  </li>
  <li><a href="#toc3">Adicionando o disco no QEMU</a>
  </li>
  <li><a href="#toc4">Acesso direto ao disco</a>
    <ul>
    <li><a href="#toc5">4.1. Cache de disco</a>
    </li>
    </ul>
  </li>
  <li><a href="#toc6">Selecionando o algoritmo de escalonamento de disco</a>
  </li>
  </ol>

</div>
</nav>
<div class="body" id="body">

<section id="toc1">
<h1>1. Objetivo</h1>

<p>
O objetivo deste tutorial é servir como base para implementação e testes de um escalonador de disco. 
Iremos adicionar um novo disco no QEMU com a finalidade de testes de escalonamento. Não usaremos o <em>rootfs</em> (<em>/dev/sda</em>)
para que as requisições de acesso ao disco gerados pelo sistema não interfiram em nossos testes. 
Depois aprenderemos como selecionar entre os diferentes escalonadores de disco disponíveis. 
</p>

</section>
<section id="toc2">
<h1>2. Criando uma imagem de disco</h1>

<p>
Criaremos um arquivo que servirá como disco de testes para o nosso escalonador de discos. 
Tal arquivo terá como tamanho 1GB, portanto, não se preocupe em salvá-lo em seus repositórios. O nosso disco não
conterá um sistema de arquivos válido, pois, faremos acessos a setores do disco diretamente sem considerar o sistema de arquivos.
Use o comando <em>dd</em> para criar um arquivo, usando como entrada <em>/dev/zero</em> e como saída o arquivo sdb.bin. O parâmetro <em>bs</em>
é o <em>block size</em>, ou seja, o tamanho de cada bloco de dados. Enquanto que <em>count</em> é a quantidade de blocos copiados. Assim,
512*2097152=1GB. No diretório do <em>Buildroot</em>, execute:
</p>

<pre>
$ dd if=/dev/zero of=sdb.bin bs=512 count=2097152
</pre>

</section>
<section id="toc3">
<h1>3. Adicionando o disco no QEMU</h1>

<p>
Agora queremos que o QEMU reconheça o arquivo <em>sdb.bin</em> como uma imagem de disco. Observe que, um disco não
precisa ter um sistema de arquivos para isso. O sistema de arquivos poderia ser criado através do Linux emulado pelo QEMU. Ainda,
poderíamos usar ferramentas como <em>mkfs.ext4</em> ou <em>mkfs.fat</em> para criar o sistema de arquivos. Contudo, isso não será necessário.
Para adicionar a nova imagem de disco ao QEMU é necessário incluir o mesmo no comando de execução do QEMU.
</p>

<pre>
$ qemu-system-i386 --kernel output/images/bzImage --hda output/images/rootfs.ext2 --hdb sdb.bin --nographic --append "console=ttyS0 root=/dev/sda"
</pre>

<p>
Ao executar o QEMU, deve aparecer um dispositivo <em>sdb</em> no sistema:
</p>

<pre>
# ls /dev/sdb -lh
brw-------    1 root     root        8,  16 Sep 18 18:15 /dev/sdb
</pre>

<p>
A imagem de disco será acessada através do dispositovo <em>/dev/sdb</em>.
</p>

</section>
<section id="toc4">
<h1>4. Acesso direto ao disco</h1>

<p>
Podemos acessar um disco de maneira <em>raw</em>, ou seja, sem passar por um sistema de arquivos. Para tanto, basta abrirmos o dispositivo <em>/dev/sdb</em> e usar as funções <em>read()/write()/lseek()</em> para
ler, escrever e posicionar-se no disco. Veja que, isso parece muito com acesso a um arquivo comum. Veja o exemplo abaixo:
</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

#define BUFFER_LENGTH 256
#define DISC_SZ	1073741824

int main(){
	int fd;
	char buf[BUFFER_LENGTH] = "Hello World!";

	fd = open("/dev/sdb", O_RDWR);
	if (fd &lt; 0){
		perror("Failed to open the device...");
		return errno;
	}
	
	/* Posicionar-se no inicio do disco. */
	lseek(fd, 0, SEEK_SET);
	
	/* executa leitura. */
	write(fd, buf, strlen(buf));
	
	close(fd);
	
	return 0;
}
</pre>

<p>
O exemplo acima irá escrever a mensagem <em>"Hello World!"</em> no inicio do disco. Crie o diretório <em>disk-test</em> dentro do diretório principal do <em>Buildroot</em> e coloque o fonte para testes lá. Será necessário primeiramente compilar o exemplo com o compilador cruzado, adicionar o binário resultante no <em>rootfs</em> (como por exemplo no diretório /buildroot/output/target/usr/bin/) e gerar novamente o sistema de arquivos. Para utilizar o compilador cruzado, adicione a toolchain no PATH do sistema, confome abaixo (ajuste o caminho de acordo com o ambiente de desenvolvimento).
</p>
<p>
$ export PATH=$PATH:~/linuxdistro/buildroot/output/host/bin
</p>
<p>
Observe que as aplicações de usuário não enxergam os setores do disco. Isso é tratado dentro do kernel. Contudo, podemos saber qual setor do disco está sendo acessado. Para isso, basta pegar a posição atual no disco e dividir pelo tamanho do setor. Por exemplo, se a aplicação for acessar a posição 10030 do disco, isso significa setor 19 (10030/512=19,58). 
</p>
<p>
Execute o exemplo acima na sua distribuição Linux. Depois, na sua *máquina host*, execute o comando abaixo. Será possível ver a mensagem no início do disco.
</p>

<pre>
$ hexdump -C sdb.bin
00000000  48 65 6c 6c 6f 20 57 6f  72 6c 64 21 00 00 00 00  |Hello World!....|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
40000000
</pre>

<section id="toc5">
<h2>4.1. Cache de disco</h2>

<p>
O Linux mantem uma cache dos acessos de leitura do disco. Isso significa que cada leitura no disco é armazenada temporariamente na memória, caso seja acessada novamente no futuro próximo.
Contudo, o Linux não carrega para a memória apenas o setor acessado, ele carrega uma página, ou seja, tipicamente 4KB. Isso significa 8 setores em um disco com 512 bytes por setor. As escritas são
executadas assim que possível. Contudo, uma escrita em uma região do disco que ainda não esta em cache irá requirer primeiramente a leitura da página. Isso acontece por que o disco aceita apenas
escritas/leituras em blocos e o menor bloco de escrita é o setor. Assim, mesmo que apenas um 1 byte seja modificado em um setor, será necessário carregar uma página na memória, modificar o byte em memória,
e assim, realizar a escrita no disco. 
</p>
<p>
É possível esvaziar a cache de disco no Linux com o comando abaixo. Isso será necessário em nossos testes com escalonadores de disco. Esse comando deve ser executado dentro da distribuição gerada anteriormente.
</p>

<pre>
$ echo 3 &gt; /proc/sys/vm/drop_caches;		
</pre>

</section>
</section>
<section id="toc6">
<h1>5. Selecionando o algoritmo de escalonamento de disco</h1>

<p>
O Linux implementa algumas políticas de escalonamento que podem ser selecionadas através do <em>sys/</em>. É possível selecionar uma política diferente para cada disco do sistema. 
</p>
<p>
Veja as políticas de disco disponíveis para o dispostivo <em>sdb</em> com o comando abaixo:
</p>

<pre>
$ cat /sys/block/sdb/queue/scheduler
noop deadline [cfq] 
</pre>

<p>
O algoritmo em execução é apresentado entre colchetes. Obtenha mais informações sobre os escalonadores de disco, configuração de parâmetros de escalonadores e gerenciamento em: <a href="http://cromwell-intl.com/linux/performance-tuning/disks.html">http://cromwell-intl.com/linux/performance-tuning/disks.html</a>
</p>
<p>
Para trocar de algoritmo basta efetuar o comando abaixo, com o nome do algoritmo desejado:
</p>

<pre>
$ echo noop &gt; /sys/block/sdb/queue/scheduler
</pre>

<p>
Verifique se o comando funcionou:
</p>

<pre>
$ cat /sys/block/sdb/queue/scheduler
[noop] deadline cfq 
</pre>

</section>
</div>
<!-- html code generated by txt2tags 3.4 (http://txt2tags.org) -->
<!-- cmdline: txt2tags 1.1 - buildroot.t2t 1.2 - qemu-network.t2t 1.3 - iperf.t2t 2.1 - kernel_tutorial.t2t 2.2 - system_call.t2t 2.3 - driver_hello_world.t2t 2.4 - iosched.t2t 3.1 - ftrace.t2t 3.2 - ftrace2.t2t 3.3 - trace-cmd_kernelshark.t2t 3.4 - sched_low_idle_not_used.t2t 4.1 - memory_tools.t2t 4.2 - process_segments.t2t -->
</article></body></html>
